---
title: "<b>MB Graphics Report</b>"
author: "Paul M. Washburn"
date: "Through Wednesday July 5, 2017"
output: 
  pdf_document:
      df_print: "kable" 
      fig_width: 10
      fig_height: 9
---
```{python pySetup}
from pandas import read_table
df = read_table('N:/Operations Intelligence/Monthly Reports/Graphics/Raw Data/POSTER Detail_dump.txt', engine='python', doublequote=False, header=0)

col_names = {'ID':'ID',
            'DVMKET':'Warehouse',
            'DVJOBID':'JobId',
            'DVJOBNAME':'JobName',
            'DVREPRNT':'Reprint',
            'DVJBSTAT':'JobStatus',
            'DVCUSTNUM':'CustomerId',
            'DVCUSTN':'Customer',
            'CHINVDAT':'InvoiceDate',
            'DVITMID':'ItemId',
            'DVITMCAT':'ItemCategory',
            'DVITMDSC':'ItemDescription',
            'DVITMWTH':'ItemWidth',
            'DVITMHGT':'ItemHeight',
            'DVQTYORD':'QtyOrdered',
            'DVMULTPL':'GraphicsJobOption', #check with Rachel for semantics
            'DVLINAMT':'JobTotalCost',
            'DVNMBMN':'NonMajorBrandsMentions', #verify with Rachel
            'DVJOBSTR':'AccessoryPrintBanner',
            'DVSUPP':'SupplierId',
            'DVSUPNAM':'Supplier',
            'DVBRNDID':'ProductId',
            'DVBRNDNM':'Product',
            'DVSBRNID':'BrandId',
            'DVSBRNNM':'Brand',
            'DVMBMENT':'MajorBrandsMentions', #verify with Rachel
            'DVCBRATE':'ChargebackRate',
            'DVDISTCS':'PosterPrice', #verify with Rachel
            'DVCBAMT':'ChargebackAmount',
            'DVCBTOTL':'ChargebackTotal',
            'DVSPNBR':'SalespersonId',
            'DVSPNAME':'Salesperson',
            'DVIMAGE':'DVIMAGE',
            'DVAPRDIR':'Director',
            'DVBRND':'DVBRND',#DVSBRNID
            'DVITMNUM':'unsure11',
            'DVITMOPT':'DVITMOPT',
            'DVCBOVRD':'BrandMentionOverride',
            'DVGRPHDS':'Designer',
            'DVGRPHDF':'User'}
            
df.rename(columns=col_names, inplace=True)
df.Warehouse = df.Warehouse.map({'1':'Kansas City', '2':'Saint Louis', '3':'Columbia', '5':'Springfield'})
df.set_index('ID', inplace=True)
df.drop(labels=['DVIMAGE','ItemWidth','ItemHeight','DVITMOPT'], axis=1, inplace=True)

df.to_csv('N:/Operations Intelligence/Monthly Reports/Graphics/Raw Data/renamed raw data.csv', index=False)
```



```{r setup, include=FALSE}
options(stringsAsFactors = FALSE)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)

## VITAL -- MAKE SURE ALL CURRENT DESIGNERS ARE PRESENT BELOW
active_designers = c('Mueller, Rachel','Riehlman, Brittany','Wilhoit, Katie','Wright, Paige')
graphics_posterIDs = c('MUELLER, RACHEL','RIEHLMAN, BRITTANY','WILHOIT, KATIE','WRIGHT, PAIGE')

## Graphics data dump from Diver
library(dplyr)
library(zoo)
library(reshape2)
library(lubridate)
library(ggplot2)
library(googleVis)
library(stringr)
library(tidyr)
library(scales)
library(ggthemes)
library(dict)
source('C:/Users/pmwash/Desktop/R_files/Data Input/Helper.R')

MONTHS = c('January','February','March','April','May','June',
           'July','August','September','October','November','December')

## Get current years
this_yr = round(as.numeric(format(Sys.Date(), '%Y')),0)
last_yr = round(as.numeric(format(Sys.Date(), '%Y')) - 1,0)
two_yrs_ago = round(as.numeric(format(Sys.Date(), '%Y')) - 2,0)

## Get current months
this_month = as.character(lubridate::month(Sys.Date(), T, F))
last_month = as.character(lubridate::month(lubridate::month(Sys.Date())-1, T, F))
two_months_ago = as.character(lubridate::month(lubridate::month(Sys.Date())-2, T, F))
last_three_months = c(this_month, last_month, two_months_ago)

thismo_numeric = lubridate::month(Sys.Date())
month_long = function(mo) lubridate::month(mo, T, F)
ytd_months = unlist(lapply(seq(1, thismo_numeric, by=1), month_long))

pct_chg = function(new, old) {
  round(((new-old)/abs(old))*100, 1)
}
len_unique = function(x) length(unique(x))


## Read in and clean up the data

read_raw_graphics_data = function(python_path){
  df = read.csv('N:/Operations Intelligence/Monthly Reports/Graphics/Raw Data/renamed raw data.csv', header=TRUE)
  df$JobItemBrandId = paste0(as.character(df$JobId),'_',as.character(df$ItemId),'_',as.character(df$BrandId))
  df$JobItemId = paste0(as.character(df$JobId),'_',as.character(df$ItemId))
  df$JobStatus = as.character(df$JobStatus)
  df = df[order(nchar(df$JobStatus), df$JobId, decreasing=TRUE), ]
  df = df[!duplicated(df[,c('JobItemBrandId','CustomerId')]), ]
  df = df[df$JobStatus!='', ]
  df$InvoiceDate = dat = strptime(df$InvoiceDate, '%Y-%m-%d %H:%M')
  df$JobId = factor(df$JobId)
  df$InvoiceYear = lubridate::year(dat)
  df$InvoiceWeek = lubridate::week(dat)
  df$InvoiceMonth = lubridate::month(dat, TRUE, FALSE)
  #df = df[df$InvoiceYear %in% c(this_yr, last_yr, two_yrs_ago, NA), ] #check NA
  df$Profit = round(df$PosterPrice - df$ChargebackTotal, 2)
  return(df)
}

python_path = 'N:/Operations Intelligence/Monthly Reports/Graphics/Raw Data/renamed raw data.csv'
df = read_raw_graphics_data(python_path)

check_raw_pipeline = function(df){
  check_df = df[!grepl('Assembled and Shipped', df$JobStatus), c('JobItemBrandId','JobStatus','Designer')]
  check_df$JobStatus = substrRight(check_df$JobStatus, 45)
  return(check_df)
}
#check_raw_pipeline(df)

## Filter for testing ONLY
#print('If you see this message, take this filter off')
#df = head(df,10000)


## Specify functions 
extract_stage_name = function(job_status) {
  drop_dates = function(x) gsub("\\s*\\([^\\)]+\\)","", as.character(x))
  drop_spaces = function(x) gsub('[[:space:]]','',x)
  drop_second_element = function(x) strsplit(as.character(x), split="\\(")[1]
  
  unlisted_status = sapply(unlist(job_status), drop_dates)
  unlisted_status = sapply(unlisted_status, drop_spaces)
  unlisted_status = sapply(unlisted_status, drop_second_element)
  
  return(unlisted_status)
}

munge_date = function(dat) format(strptime(dat, '%b %d %Y %I:%M%p'), '%Y-%m-%d %H:%M')  

extract_dates_fromtext = function(job_status, i, j) {
  dat = regmatches(job_status[[i]][j], gregexpr("(?=\\().*?(?<=\\))", job_status[[i]][j], perl=T))  
  dat = gsub("[()]", "", dat)
  dat = gsub("\\s+", " ", dat)
  dat = munge_date(dat)
  return(dat)
}


## Get string for job status - parse for turnaround
job_status = as.character(df$JobStatus)
names(job_status) = df$JobId
job_status = strsplit(job_status, ',')

goodCols = c('Incomplete','AwaitingGraphicsAssignment','AwaitingBrandMentions','AwaitingCostApproval',
             'AwaitingArtwork','AwaitingRequesterApproval','AwaitingJobCompletion','AssembledandShipped',
             'IncompleteStatus1','IncompleteStatus2','IncompleteStatus3',
             'IncompleteStatus4','IncompleteStatus5','IncompleteStatus6','IncompleteStatus7',
             'IncompleteStatus8','IncompleteStatus9','IncompleteStatus10',
             'BrandMentionsEntered1','BrandMentionsEntered2','BrandMentionsEntered3','BrandMentionsEntered4',
             'BrandMentionsEntered5','BrandMentionsEntered6','BrandMentionsEntered7','BrandMentionsEntered8',
             'BrandMentionsEntered9','BrandMentionsEntered10',
             'ArtworkRedesign1','ArtworkRedesign2','ArtworkRedesign3','ArtworkRedesign4','ArtworkRedesign5',
             'ArtworkRedesign6','ArtworkRedesign7','ArtworkRedesign8','ArtworkRedesign9','ArtworkRedesign10')
colsToKeep = c(unlist(colnames(df)), unlist(goodCols))

for(i in 1:length(job_status)) {
  job_stages = extract_stage_name(job_status[i]); print(i)
  
  incompleteStatus = 1
  brandMentionsStatus = 1
  artworkRedesigns = 1
    
  for(j in 1:length(job_stages)) {
    colname = as.character(job_stages[j])
    try({
      if(colname %in% names(df)) {
        if((j != 1) & ('Incomplete' %in% colname)){
          DAT = extract_dates_fromtext(job_status, i, j)
          print(paste0(i, j, DAT, '--- INCOMPLETE STATUS ---'))
          df[i, paste0('IncompleteStatus',as.character(incompleteStatus))] = DAT
          incompleteStatus = incompleteStatus+1
        } else if ((j %!in% c(2,3)) & ('AwaitingBrandMentions' %in% colname)){
          DAT = extract_dates_fromtext(job_status, i, j)
          print(paste0(i, j, DAT, '--- RETURNED TO ENTER BRANDS ---'))
          df[i, paste0('BrandMentionsEntered', as.character(brandMentionsStatus))] = DAT
          brandMentionsStatus = brandMentionsStatus+1
        } else if ((j %!in% c(2,3)) & ('AwaitingArtworkRedesign' %in% colname)){
          DAT = extract_dates_fromtext(job_status, i, j)
          print(paste0(i, j, DAT, '--- SENT BACK FOR REDESIGN ---'))
          df[i, paste0('ArtworkRedesign', as.character(artworkRedesigns))] = DAT
          artworkRedesigns = artworkRedesigns+1
        } else {
          DAT = extract_dates_fromtext(job_status, i, j)
          print(DAT)
          df[i, colname] = DAT  
        }
      } else {
        DAT = extract_dates_fromtext(job_status, i, j)
        print(DAT)
        df[, colname] = NA
        df[i, colname] = DAT
      }
    })
  }
}
df = df[,names(df) %in% colsToKeep]



countEvents = function(df, columnIdentifier){
  columns = names(df)
  columns = columns[grepl(columnIdentifier, columns)]
  counts = !is.na(df[, columns])
  counts = rowSums(counts, na.rm=T)
  return(counts)
}

process_statuses = function(df){
  ## Count up incomplete send backs, redesigns, and times brands entered
  df$IncompleteStatusCount = countEvents(df, 'IncompleteStatus')
  df$RedesignCounts = countEvents(df, 'ArtworkRedesign')
  df$TimesBrandsEntered = countEvents(df, 'BrandMentionsEntered')
  
  ## Obtain time spent in each category
  df$JobTurnaround = round(difftime(df$AssembledandShipped, df$Incomplete, units="days"), 1)
  df$KickoffToArtworkComplete = round(difftime(df$AwaitingArtwork, df$Incomplete, units="days"), 1)
  
  ## Get month/year when a given job started
  df$KickoffMonth = as.character(lubridate::month(df$Incomplete, label=T, abbr=F))
  df$KickoffWeek = lubridate::week(df$Incomplete)
  df$KickoffYear = kick_yr = as.character(year(df$Incomplete))
  
  return(df)
}
  
df = process_statuses(df)


pipeline_information = function(df){
  df$JobStarted = strtd = !is.na(df$Incomplete)
  df$JobFinished = finsd = !is.na(df$AssembledandShipped)
  in_pipeline = aggregate(JobFinished ~ JobId, data=df, FUN=max)
  in_pipeline = unlist(in_pipeline[in_pipeline$JobFinished == 0, 'JobId'])
  df$InPipeline = df$JobId %in% in_pipeline
  return(df)
}  

df = pipeline_information(df)
  
get_and_check_pipeline = function(df){
  dfPipe = df[(df$InPipeline == T), ]
  today = as.character(Sys.Date())
  colsToCheck = c('Designer','JobId','JobStatus','Salesperson','Customer','Warehouse','PosterPrice',
                  'Incomplete','AwaitingBrandMentions','BrandMentionsEntered1','BrandMentionsEntered2','BrandMentionsEntered3',
                  'AwaitingArtwork','ArtworkRedesign1','ArtworkRedesign2','ArtworkRedesign3','AwaitingRequesterApproval',
                  'AwaitingJobCompletion','AssembledandShipped', 'IncompleteStatusCount')
  dfPipe = dfPipe[,colsToCheck]
  write.csv(dfPipe,paste0('C:/Users/pmwash/Desktop/Disposable Docs/Pipeline as of ',today,'.csv'))
  print('Written to file')
  return(dfPipe)
}




redesigns_menus_accessories = function(df) {
  ## Mark redesigns, reprints, menus & accessories
  df$Reprint = sapply(toupper(df$Reprint), FUN=function(s) gsub('"', '', s) == 'TRUE')
  df$Redesign = df$RedesignCounts > 0
  accessories = c('Menu Books','Table Top Wrap','TT A-Frame Holder','TT A-Frame Holder (Holder Only)', 
                  'TT Acrylic Stand','TT Acrylic Stand (Stand Only)','TT Flip Stand','TT Flip Stand (Stand Only)',
                  'Vivid Board - Dry Erase','Vivid Board - Dry Erase','Light Box')
  menus = c('Menu Books','Drink List','Folded Drink List','Tri-Fold Drink List','Folded Menu Cards','Menu Card - Small Format (QTY = Total Pages)')
  df$Menu = df$ItemCategory %in% menus
  df$Accessory = df$ItemCategory %in% accessories
  return(df)
}


df = redesigns_menus_accessories(df)



get_common_columns = function(df, string) names(df)[grepl(string, names(df))]

## Mark last date in record as date of record
brand_mention_columns = get_common_columns(df,'BrandMentions')
df$BrandMentionsFinalized = apply(df[, brand_mention_columns], 1, function(x) as.POSIXct(max(x, na.rm=T)))
df$BrandMentionsFinalized = as.Date.POSIXct(df$BrandMentionsFinalized)


get_milestones = function(df){
  the_milestones = data.frame(df$Incomplete, df$AssembledandShipped)
  df$DayOfRecord = dat = apply(the_milestones, 1, function(x) max(x, na.rm=T))
  df$MonthOfRecord = lubridate::month(dat, T, F)
  df$WeekOfRecord = lubridate::week(dat)
  df$YearOfRecord = lubridate::year(dat)
  df$DayOfMonthOfRecord = lubridate::mday(dat)
  df$WeekdayOfRecord = lubridate::wday(dat, T, F)
  df$DOTY = lubridate::yday(dat)
  df = df[order(df$YearOfRecord, df$JobId, df$DayOfRecord, decreasing=T), ]
  return(df)
}

df = get_milestones(df)


## Push this merge to python when time permits
slsLookup = 'C:/Users/pmwash/Desktop/Re-Engineered Reports/Generalized Lookup Data/pw_slp2.csv'
read_pwslp2 = function(path){
  pw_slp2 = read.csv(path, header=TRUE)
  names(pw_slp2) = c('SalespersonId','Salesperson','DirectorId')
  pw_slp2$DirectorId = NULL
  return(pw_slp2)
}

df$Salesperson = NULL
df = merge(df, read_pwslp2(slsLookup), on='SalespersonId', how='outer')



## Write to CSV for Python
write.csv(df, 'C:/Users/pmwash/Desktop/Re-Engineered Reports/Graphics/intermediate_graphics_data_dump_diver.csv',
          row.names=FALSE)





get_this_and_last_year_data = function(df){
  ## Isolate this year and last year data only
  df_thisyr_lastyr = df[(df$YearOfRecord %in% c(this_yr, last_yr)), ] #check why missing (df$Designer %in% active_designers)
  
  invoiced_firstmos = (df_thisyr_lastyr$InvoiceMonth %in% ytd_months)
  kickdoff_firstmos = (df_thisyr_lastyr$KickoffMonth %in% ytd_months)
  
  df_ytd_thislast = df_thisyr_lastyr[invoiced_firstmos | kickdoff_firstmos, ]
  
  year_of_record = df_ytd_thislast$YearOfRecord
  df_ytd_thislast$DayOfYearOfRecord = doty = lubridate::yday(df_ytd_thislast$DayOfRecord)
  today_doty = lubridate::yday(Sys.Date())
  df_ytd_thislast = df_ytd_thislast[doty <= today_doty, ]
  return(df)
}

df_thisyr_lastyr = get_this_and_last_year_data(df)




get_this_year_data_only = function(df, this_yr, active_designers){
  df_thisyr = df[df$KickoffYear == this_yr | df$InvoiceYear == this_yr, ]
  df_thisyr <- df_thisyr[df_thisyr$Designer %in% active_designers, ]
  return(df_thisyr)
}

df_thisyr = get_this_year_data_only(df, this_yr, active_designers)



get_ytd_this_and_last_year = function(last_yr){
  doy = lubridate::yday(Sys.Date())
  day_seq = seq(1, doy, 1)
  return(day_seq)
}

days_so_far = get_ytd_this_and_last_year(last_yr)
df_ytd_thislast = df[df$DOTY %in% days_so_far & df$YearOfRecord %in% c(this_yr, last_yr), ]





## Get number of jobs and items by salespeople
countJobsBySalesperson = function(df_thisyr){
  uniqueJobs = aggregate(cbind(JobId, JobItemId) ~ Salesperson, data=df_thisyr, FUN=len_unique)
  return(uniqueJobs)
}

getSalesJobs = function(uniqueJobs, graphics_as_salespeople, sales_only){
  if(sales_only==F){
    uniqueJobs = uniqueJobs[uniqueJobs$Salesperson %in% graphics_as_salespeople, ]  
  }else{
    uniqueJobs = uniqueJobs[uniqueJobs$Salesperson %!in% graphics_as_salespeople, ]
  }
  rownames(uniqueJobs) = uniqueJobs$Salesperson
  uniqueJobs$Salesperson = NULL
  uniqueJobs = uniqueJobs[order(uniqueJobs$JobId, decreasing=T),]
  names(uniqueJobs) = c('Jobs Requests Input','Job Items Input')
  return(uniqueJobs)
}

uniqueJobs = countJobsBySalesperson(df_thisyr)
bygraphics = getSalesJobs(uniqueJobs, graphics_posterIDs, sales_only=FALSE)
byrequester = getSalesJobs(uniqueJobs, graphics_posterIDs, sales_only=TRUE)



## Turnaround later on
getTurnaround = function(df, col_group){
  df = df[df$Designer %in% active_designers & df$YearOfRecord %in% c(this_yr, last_yr), ]
  turnaround = aggregate(df$JobTurnaround ~ df[, col_group], FUN=function(x) round(mean(as.numeric(x), na.rm=T), 1))
  names(turnaround) = c('X','Turnaround')
  turnaround = turnaround[order(turnaround$Turnaround, decreasing=T),]
  rownames(turnaround) = turnaround$X
  turnaround$X = NULL
  return(turnaround)
}

turnaround = getTurnaround(df, 'Designer')
turnaround_sls = head(getTurnaround(df, 'Salesperson'), 25)
turnaround_cus = head(getTurnaround(df, 'Customer'), 25)
turnaround_hse = head(getTurnaround(df, 'Warehouse'), 25)
turnaround_acc = head(getTurnaround(df, 'AccessoryPrintBanner'), 25)

#turn_dfs = list(turnaround, turnaround_sls, turnaround_cus, turnaround_hse, turnaround_acc)
```


# Measures of success for Graphics Team

This section was designed to help the Graphics department and management gain insight into the Graphics operation. In contrast, the next major section of this report is geared towards Graphics' impact on Sales and the organization at-large. Unless otherwise specified, the data considered is from all jobs submitted this year, and the data is accessed via a large dump from Diver of all fields and all dates available in the system.

## Jobs Entered by Graphics Team

Below shows jobs that were entered by the Graphics team on behalf of the sales team. 

```{r requests_inputbygraphics}
bygraphics
```


## Turnaround by Designer
Figures below include weekends and holidays (i.e. holidays and weekends are not backed out of the duration calculations), and durations are measured in days. Active designers include Rachel, Brittany, Katie and Paige; all others are filtered out of the dataset. If this should not be the case please email Paul Washburn to change the filter criteria. Data considered is from this year and last year.

```{r turnaround}
turnaround
```

```{r turnaround_plot, fig.height=5, fig.width=9}
plot_turnaround = function(turnaround){
  plt = ggplot(turnaround, aes(x=rownames(turnaround), y=Turnaround, group=rownames(turnaround))) +
    geom_bar(stat='identity', position='dodge', aes(fill=rownames(turnaround)), colour='black') +
    theme_minimal() +
    theme(axis.text.x=element_text(angle=90, hjust=1)) +
    labs(x='', y='Days', title='Top 25 Longest Average Turnaround (Days)') +
    theme(legend.position='none') + coord_flip()
  print(plt)
  return(plt)
}

print('By Designer')
plot_turnaround(turnaround)
```

## Turnaround by Salesperson, Customer & House
Data considered is from this year and last year. All other caveats above hold for the plots below.

By Salesperson.

```{r turnaround_plot_sls, fig.height=5, fig.width=9}
print('By Salesperson')
plot_turnaround(turnaround_sls)
```

By Customer.
```{r turnaround_plot_cus, fig.height=5, fig.width=9}
print('By Customer')
plot_turnaround(turnaround_cus)
```

By House.
```{r turnaround_plot_hse, fig.height=5, fig.width=9}
print('By House')
plot_turnaround(turnaround_hse)
```


<!-- ## Reprints by Designer -->

<!-- Total number of reprints for the current year, by Designer. Percent of Total is shown as a percent; in other words, it has been multiplied by 100 (e.g. 1.2 indicates 1.2%, or 0.012). Reprints are counted at the Job ID level, meaning a job with 10 items marked as reprints will be counted one time. It is possible to add in reprints at the Job Item level if this information is desired. -->

<!--
# ```{r reprints}
# process_df = function(df) {
#   rownames(df) = df$Designer
#   df$Designer = df$variable = NULL
#   return(df)
# }
# 
# reprints = df[(df$Reprint==T) & (df$YearOfRecord %in% c(this_yr, last_yr)), ]
# reprints = reprints[order(reprints$YearOfRecord, reprints$JobId, reprints$DayOfRecord, decreasing=T), ]
# 
# reprint_cols = c('JobId','Designer')
# no_dupes = !duplicated(reprints[, reprint_cols])
# reprints = reprints[no_dupes, c('JobId','Designer','Reprint','YearOfRecord')]
# reprints = aggregate(Reprint ~ Designer, data=reprints, FUN=sum)
# 
# tot_jobs = aggregate(JobId ~ Designer, data=df_thisyr, FUN=len_unique)
# reprints = merge(reprints, tot_jobs, by='Designer', how='all')
# reprints = process_df(reprints)
# 
# ## Specify column names
# names(reprints) = c('Number of Reprints', 'Total Jobs')
# reprints$`Reprints as % of Total Jobs` = round((reprints$`Number of Reprints` / reprints$`Total Jobs`)*100, 1)
# # reprints
# ```


```{r reprint_plot, fig.height=5, fig.width=9}
reprints_t = data.frame(t(reprints))
names(reprints_t) = gsub('\\..', ', ', names(reprints_t))
reprints_t$Name = rownames(reprints_t)
rownames(reprints_t) = NULL
reprints_t_melt = melt(reprints_t, 'Name', active_designers)

ggplot(reprints_t_melt, aes(x=variable, y=value, group=Name)) +
  geom_bar(stat='identity', position='dodge', aes(fill=variable), colour='black') +
  facet_wrap(~Name, ncol=4, scales='free_y') +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  labs(x='', y='', title='Reprint Summary')
```
-->

## Redesigns

A Job is marked as having experienced a Redesign in the event that the "AwaitingArtworkRedesign" text was discovered in the text field in POSTer that marks each stage of the Job. It is important to note that there are considerably more Print jobs than there are Accessory jobs. 

All data for Redesigns is filtered to include only records up until today for both this year and last year.

### Redesigns for Accessories v. Print Jobs

Accessory vs. Print jobs. 

```{r redesign_plt, fig.height=10, fig.width=9}
designer_summary = function(df, col, active_designers, FUN, agg_col='JobTurnaround'){
  colz = c('JobItemId', 'JobId', 'Redesign', 'JobTurnaround',
                  'Reprint', 'Salesperson', 'ItemCategory', 'Designer',
                  'Accessory', 'Menu', 'YearOfRecord', 'Warehouse')
  df = df[df$Designer %in% active_designers, colz]
  turnaround_summary = aggregate(df[,agg_col] ~ df[,'Designer'] + df[, col], FUN=FUN)
  turnaround_summary = data.frame(setNames(turnaround_summary, c('Designer', as.character(col), as.character(agg_col))))
  return(turnaround_summary)
}

plot_redesigns = function(TurnaroundData, col, title) {
  plt = ggplot(data=TurnaroundData, 
               aes(x=Designer, y=JobTurnaround, group=TurnaroundData[,col])) +
    geom_bar(stat='identity', position='dodge', aes(fill=TurnaroundData[,col])) +
    geom_jitter(alpha=0.02) +
    theme_minimal() +
    theme(axis.text.x=element_text(angle=90, hjust=1)) +
    labs(x='', y='Avg Turnaround in Days', 
         title=title) +
    scale_y_continuous(labels=comma) +
    guides(fill=guide_legend(as.character(col)))
  return(plt)
}

plot_redesigns(designer_summary(df_thisyr_lastyr, 'Menu', active_designers, function(x) mean(x, na.rm=T)), 
               'Menu', title='Turnaround: Menu vs. Non-Menus')
plot_redesigns(designer_summary(df_thisyr_lastyr, 'Redesign', active_designers, function(x) mean(x, na.rm=T)), 
               'Redesign', title='Turnaround: Redesigns vs. Non-Redesigns')
plot_redesigns(designer_summary(df_thisyr_lastyr, 'Reprint', active_designers, function(x) mean(x, na.rm=T)), 
               'Reprint', title='Turnaround: Reprints vs. Non-Reprints')
plot_redesigns(designer_summary(df_thisyr_lastyr, 'Warehouse', active_designers, function(x) mean(x, na.rm=T)), 
               'Warehouse', title='Turnaround: by Warehouse')
```



### Redesigns by Designer

Below shows the number of Jobs marked as "redesign" in PostER. Please note that if a job was redesigned and then assigned to another designer, then the new designer will be associated with the redesign (e.g. Designer A started a project, then it was sent back for redesign and assigned to Designer B, then Designer B will be attributed with the redesign since there is no way to tie the two jobs together in the data).

Data considered is YTD for both this year and last year (e.g. 1/1/LASTYR - 8/5/LASTYR AND 1/1/THISYR - 8/5/THISYR).

Percentages, as it is throughout this document, are shown as %. To re-iterate, data for Redesigns shows information through today (i.e. June 20th's day of the year is 171) for both this year and last.

```{r redesigns_des}
unique_jobs_thislast = df_ytd_thislast[!duplicated(df_ytd_thislast$JobId), ]

redesigns_bydesigner = designer_summary(unique_jobs_thislast, 'YearOfRecord', active_designers, function(x) sum(x, na.rm=T), agg_col='Redesign')

display_yoy <- function(df, agg_col, subject_col) {
  df = df[df$YearOfRecord %in% c(this_yr, last_yr), ]
  df = tidyr::spread_(df, 'YearOfRecord', agg_col)
  df$`Percent (%) Change` = pct_chg(new=df[, as.character(this_yr)], old=df[, as.character(last_yr)])
  return(df)
} 

set_rownames <- function(df, rowname_col, sort_col) {
  rownames(df) = df[, as.character(rowname_col)]
  df[, as.character(rowname_col)] = NULL
  df = df[order(df[, as.character(sort_col)], decreasing=TRUE), ]
  return(df)
}

redesigns_designer_summary = display_yoy(redesigns_bydesigner, agg_col='Redesign', subject_col='Designer')
redesigns_designer_summary = set_rownames(redesigns_designer_summary, 'Designer', as.character(this_yr))
redesigns_designer_summary
```


### Redesigns by Salesperson

Below displays the top 15 salespeople as measured by the number of times they sent jobs back to Graphics for Redesigns.

```{r redesigns_sls}
salesperson_summary <- function(df, col, active_designers, FUN, agg_col='JobTurnaround'){
  colz = c('JobItemId', 'JobId', 'Redesign', 'JobTurnaround',
                  'Reprint', 'Salesperson', 'ItemCategory', 'Designer',
                  'Accessory', 'Menu', 'YearOfRecord', 'Warehouse')
  df = df[df$Salesperson %!in% active_designers, colz]
  turnaround_summary = aggregate(df[, agg_col] ~ df[, 'Salesperson'] + df[, col], FUN=FUN)
  turnaround_summary = data.frame(setNames(turnaround_summary, c('Salesperson', as.character(col), as.character(agg_col))))
  return(turnaround_summary)
}

redesigns_bysalesperson <- salesperson_summary(unique_jobs_thislast, 'YearOfRecord', graphics_posterIDs, function(x) sum(x, na.rm=T), agg_col='Redesign')
redesigns_bysalesperson_summary <- display_yoy(redesigns_bysalesperson, agg_col='Redesign', subject_col='Salesperson')
redesigns_bysalesperson_summary <- set_rownames(redesigns_bysalesperson_summary, 'Salesperson', as.character(this_yr))

head(redesigns_bysalesperson_summary, 15)
```

Figures below adjust for a given Salesperson's utilization rate of the Graphics team's resources. Both axes are shown as logs of the value to show the names more clearly -- for visual purposes only. Individuals well above the line are committing re-designs more often than is normal for their given level of Graphics utilization. Note that there are many salespeople that are not shown because they had no Redesigns at all (i.e. they are on the X axis below and hard to see), yet still did many Jobs. This indicates it is possible to do a lot of jobs without having many Redesigns. 

Salespersons with both more than 10 jobs and 2 redesigns are considered below; all others are filtered out. Data is YTD for both this year and last year (i.e. "through today" for both this and last year).

```{r sls_plot_reds, fig.height=5, fig.width=9}
sls_x = salesperson_summary(unique_jobs_thislast, 'Warehouse', graphics_posterIDs, function(x) sum(x, na.rm=T), agg_col='Redesign')
sls_redesigns_context <- salesperson_summary(unique_jobs_thislast, 'Warehouse', graphics_posterIDs, len_unique, agg_col='JobId')
sls_redesigns_context <- merge(sls_redesigns_context, sls_x, by=c('Salesperson', 'Warehouse'), how='outer')
sls_redesigns_context <- sls_redesigns_context[sls_redesigns_context$Salesperson %!in% graphics_posterIDs, ]
sls_redesigns_context$PctRedesigns <- sls_redesigns_context$Redesign / sls_redesigns_context$JobId
sls_redesigns_context <- sls_redesigns_context[order(sls_redesigns_context$PctRedesigns, decreasing=T), ]
names(sls_redesigns_context) = c('Salesperson','Warehouse','Jobs','Redesigns','PercentRedesigns')
sls_redesigns_context <- sls_redesigns_context[sls_redesigns_context$Jobs >= 10 & sls_redesigns_context$Redesigns > 2, ]
head(sls_redesigns_context)

plt_redesigns_sls = ggplot(sls_redesigns_context, 
                           aes(x=Jobs, y=Redesigns, group=Warehouse)) +
  geom_point(alpha=.7) + 
  geom_text(position='jitter', 
             aes(x=Jobs, y=Redesigns, vjust='inward', hjust='inward',
                label=Salesperson, size=scale(PercentRedesigns - mean(PercentRedesigns))+2, colour=Warehouse),
            colour='blue', alpha=.9, check_overlap=T) +
  geom_smooth(se=T, alpha=0.3, fill='gray', method='lm', aes(group=Warehouse, colour=factor(Warehouse))) +
  theme_minimal() +
  theme(legend.position='none') +
  scale_x_log10() + scale_y_log10() +
  labs(title='Redesigns vs. Number of Jobs Submitted\nBy Warehouse', x='Log Jobs', y='Log Redesigns') +
  facet_wrap(~Warehouse, ncol=2, scales='free')
plt_redesigns_sls
```







## Total Price & Mentions by Designer

```{r price_mentions_plot}
## melt and isolate data by designer
val_cols = c('PosterPrice','MajorBrandsMentions')
id_cols = c('Designer','MonthOfRecord')

extract_price_mentions <- function(df_thisyr, active_designers) {
  bydesigner_melt = df_thisyr[, c('PosterPrice', 'MajorBrandsMentions', 'MonthOfRecord', 'Designer')]
  bydesigner_melt = melt(df_thisyr[df_thisyr$Designer %in% active_designers, ], id_cols, val_cols)
  bydesigner = aggregate(value ~ variable + Designer + MonthOfRecord, data=bydesigner_melt, FUN=sum)
  bydesigner = spread(bydesigner, 'MonthOfRecord', 'value')
  return(bydesigner)
}

bydesigner = extract_price_mentions(df_thisyr, active_designers)
price_mentions_dfs = split(bydesigner, bydesigner$variable)
price_df = price_mentions_dfs$PosterPrice

library(scales)
namz = names(bydesigner)
namz = c(unlist(namz[namz %!in% c('variable','Designer')]))
mentions_df_melt = melt(bydesigner, c('variable','Designer'), namz)
names(mentions_df_melt) = c('var','Designer','MonthOfRecord','value')

ggplot(mentions_df_melt, aes(x=MonthOfRecord, y=value, group=Designer)) +
  geom_line(aes(colour=Designer)) +
  geom_point(alpha=0.6) +
  facet_wrap(~var, nrow=2, scales='free_y') +
  theme_minimal() +
  labs(title='Total Price and Mentions per Month by Designer', x='', y='') +
  scale_y_continuous(labels=comma)
```


## Cost by Designer

A monthly sum of Poster Price, shown by month.

```{r price_bydesigner, fig.height=7, fig.width=9}
process_df(price_df)
```

```{r costs_bydesigner_plot, fig.height=5, fig.width=9}
price_t = data.frame(t(process_df(price_df)))
names(price_t) = gsub('\\..', ', ', names(price_t))
price_t$Name = rownames(price_t)
rownames(price_t) = NULL
price_t_melt = melt(price_t, 'Name', active_designers)
price_t_melt$Name = factor(price_t_melt$Name, levels=MONTHS) 

ggplot(price_t_melt, aes(x=Name, y=value, group=variable)) +
  geom_bar(stat='identity', position='dodge', aes(fill=variable), colour='black') +
  facet_wrap(~variable, ncol=4) +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  labs(x='', y='Dollars', title='Sum of Poster Price per Month by Designer') +
  scale_y_continuous(labels=dollar)
```


## Brand Mentions by Designer
Sum of all MB mentions by Designer for the current year, shown by month. 

```{r mentions_bydesigner}
mentions_df = price_mentions_dfs$MajorBrandsMentions
process_df(mentions_df)
```

Total number of brand mentions by Designer YTD.
```{r rowsums}
ttments = data.frame(t(rowSums(process_df(mentions_df), na.rm=T)))
rownames(ttments) = 'Tot Brand Mentions YTD'
names(ttments) = gsub('\\..',', ',names(ttments))
ttments
```

Average number of brand mentions per month by Designer YTD.

```{r rowmns}
avgments = data.frame(t(rowMeans(process_df(mentions_df), na.rm=T)))
rownames(avgments) = 'Avg Brand Mentions per Month'
names(avgments) = gsub('\\..',', ',names(avgments))
avgments
```



```{r mentions_plot, fig.height=5, fig.width=9}
mentions_t = data.frame(t(process_df(mentions_df)))
names(mentions_t) = gsub('\\..', ', ', names(mentions_t))
mentions_t$Name = rownames(mentions_t)
rownames(mentions_t) = NULL
mentions_t_melt = melt(mentions_t, 'Name', active_designers)
mentions_t_melt$Name = factor(mentions_t_melt$Name, levels=MONTHS) 

ggplot(mentions_t_melt, aes(x=Name, y=value, group=variable)) +
  geom_bar(stat='identity', position='dodge', aes(fill=variable), colour='black') +
  facet_wrap(~variable, ncol=4) +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  labs(x='', y='Number of Brand Mentions', title='Brand Mentions per Month by Designer')
```



## Number of Jobs per Month by Designer

Total number of jobs "WORKED ON" per month by designer. Figures below show a job if it was "touched" at all during the timeframe in question.

```{r jobspermo_bydesigner}
jobspermo = aggregate(JobId ~ Designer + MonthOfRecord, data=df_thisyr, FUN=len_unique)
jobspermo = spread(jobspermo, 'MonthOfRecord', 'JobId')
jobspermo = process_df(jobspermo)
jobspermo
```

YTD total number of jobs by designer.

```{r totjobrowsums}
tottjobs = data.frame(t(rowSums(jobspermo, na.rm=T)))
rownames(tottjobs) = 'Tot Jobs  YTD'
names(tottjobs) = gsub('\\..',', ',names(tottjobs)) 
tottjobs
```

YTD average number of jobs per month by designer.

```{r meanjobrowmeans}
avgjobs = data.frame(t(rowMeans(jobspermo, na.rm=T)))
rownames(avgjobs) = 'Avg Jobs per Month'
names(avgjobs) = gsub('\\..',', ',names(avgjobs)) 
avgjobs
```



```{r, fig.height=5, fig.width=9}
t_jobs = data.frame(t(jobspermo))
t_jobs$Month = row.names(t_jobs)
rownames(t_jobs) = NULL
t_jobs = melt(t_jobs, 'Month', gsub(', ','..',active_designers))
t_jobs$variable = gsub('\\..', ', ', t_jobs$variable)
t_jobs$Month = factor(t_jobs$Month, levels=MONTHS)

ggplot(data=t_jobs, aes(x=Month, y=value, group=variable)) +
  geom_line(aes(colour=variable)) +
  geom_point(alpha=.6, size=1.5) +
  labs(x='Month', y='Number of Jobs', title='Number of Jobs Worked On per Month\nBy Designer') +
  theme_minimal()
```


<!-- ## Pipeline & Carrying Costs by Designer -->

<!-- Summary of current jobs in the pipeline. Only jobs that have a Incomplete date yet do not have a Ship date are considered. It is important to note that some jobs are effectively "cancelled" or  "killed" in the sense that they are sent back to "Incomplete" status. This will make the Pipeline look larger than it truly is unless those jobs are removed from the system. Alternatively, a field could be created to mark them as "cancelled". -->

<!-- ```{r pipelinex} -->
<!-- colz = c('DayOfRecord','YearOfRecord','WeekOfRecord','DayOfMonthOfRecord', -->
<!--          'DayOfMonthOfRecord','WeekdayOfRecord','MonthOfRecord', -->
<!--          'JobId','JobItemId', -->
<!--          'PosterPrice','ItemCategory', -->
<!--          'Designer','InPipeline','MajorBrandsMentions', -->
<!--          'Incomplete','AssembledandShipped','JobStatus', -->
<!--          'IncompleteStatusCount') -->

<!-- inpipe = df_thisyr[df_thisyr$InPipeline==T, colz] -->

<!-- ## Check Brittany's pipeline -->
<!-- # britcheck = inpipe[inpipe$Designer == 'Riehlman, Brittany', ] -->
<!-- # britcheck = britcheck[!duplicated(britcheck$JobId), ] -->
<!-- # head(britcheck[,c('JobId','JobStatus','Incomplete','AssembledandShipped')], 10) -->

<!-- pipeline_summary = aggregate(cbind(JobId, JobItemId) ~ Designer, -->
<!--                              data=inpipe, FUN=len_unique) -->
<!-- price_summary = aggregate(cbind(PosterPrice, MajorBrandsMentions) ~ Designer, -->
<!--                              data=inpipe, FUN=function(x) round(sum(x, na.rm=T), 0)) -->
<!-- pipeline_summary = merge(pipeline_summary, price_summary, on='Designer', how='all') -->


<!-- pipeline_summary = process_df(pipeline_summary) -->
<!-- names(pipeline_summary) = c('Current Jobs', 'Current Items', 'Total Price', 'Total Mentions') -->
<!-- pipeline_summary -->
<!-- ``` -->


## Pipeline Over Time

Jobs that had a starting date but no ship date that were not jobs from this year are filtered out of the dataset below. These same types of jobs for this year are not filtered out, and are assumed to be active jobs. This may be an inaccurate assumption since there are a number of jobs that were kicked off in January of this year yet have not been finished. However, there is nothing in the data to suggest they are not still active.

A Job is considered active in the Graphics pipeline if the Job has been Kicked Off, but has not been Shipped.

```{r bydes_inpipe, fig.height=5, fig.width=9}
PIPECOLZ = c('JobId','JobItemId','Incomplete','AssembledandShipped')
inpipe_history = df[order(df$JobId), PIPECOLZ] #df_thisyr_lastyr

inpipe_history = data.frame(
  inpipe_history %>% 
    group_by(JobId) %>%
    mutate(AssembledandShipped=na.locf(AssembledandShipped, na.rm=F))
)
inpipe_history = data.frame(
  inpipe_history %>% ## sort for "unique" function to grab the first one
    arrange(AssembledandShipped, Incomplete)
)

#inpipe_history[is.na(inpipe_history$Incomplete), 'Incomplete'] = format(as.POSIXct(paste0(two_yrs_ago,'-01-01')), '%Y-%m-%d %H:%M')

## Filter & process data for jobs
DUPE_JOBS = !duplicated(inpipe_history$JobId)

job_history = inpipe_history[DUPE_JOBS, ]
rownames(job_history) = NULL

janlast_decthis = seq.Date(from=as.Date(paste0(two_yrs_ago,'-01-01')), #last_year
                           to=as.Date(Sys.Date()), by='week') #'day'
STARTS = as.Date(job_history$Incomplete)
ENDS = as.Date(job_history$AssembledandShipped) 

for(i in 1:length(janlast_decthis)){
  for(j in 1:NROW(job_history)){
    PIPEDATE = as.character(janlast_decthis[i])
    STARTED = as.Date(janlast_decthis[i]) >= as.Date(STARTS[j])
    ENDED = ifelse(is.na(ENDS[j])==TRUE, F, as.Date(janlast_decthis[i]) > as.Date(ENDS[j]))
    job_history[j, PIPEDATE] = as.numeric((STARTED==1) & (ENDED==0))
  }
}

date_history_df = t(job_history[,-c(1:4)])
PIPE = rowSums(date_history_df, na.rm=T)
PIPE = data.frame(Date=names(PIPE), Pipeline=PIPE)
PIPE$Year = lubridate::year(PIPE$Date)

### AT LATER DATE, DO JOB ITEMS TOO
## Write current pipe to file for review with graphics team
pipe_check = get_and_check_pipeline(df)
write.csv(job_history, 'C:/Users/pmwash/Desktop/Disposable Docs/Pipe Check.csv')

## Plot pipeline over time
ggplot(PIPE, aes(x=as.Date(Date), y=Pipeline, group=Year)) +
  geom_line(size=1.0, alpha=0.8, aes(colour=factor(Year))) +
  geom_point(alpha=0.7) +
  labs(x='Date', y='Number of Active Graphics Jobs', title='Pipeline as Measured by Number of Jobs, Graphics Dept.') +
  geom_smooth(aes(colour=factor(Year)), size=1.25, se=F) +
  scale_x_date(date_breaks='4 weeks', date_labels='%b %d, %y') +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  ylim(0, 205)
```


## Throughput of Graphics Department

```{r throughput, fig.height=5, fig.width=9}
throughput = job_history[, c('JobId', 'JobItemId', 'Incomplete', 'AssembledandShipped')]
throughput$MonthCompleted = lubridate::month(throughput$AssembledandShipped, T, F)
throughput$YearCompleted = lubridate::year(throughput$AssembledandShipped)
throughput = throughput[throughput$YearCompleted %in% c(this_yr, last_yr), ]
throughput = aggregate(JobId ~ MonthCompleted + YearCompleted, data=throughput, FUN=len_unique)
throughput_out = tidyr::spread(throughput, 'YearCompleted', 'JobId')

rownames(throughput_out) = throughput_out$MonthCompleted; throughput_out$MonthCompleted = NULL
throughput_out
```


## New Jobs to Graphics Department

```{r new_jobs, fig.height=5, fig.width=9}
newjobs = job_history[, c('JobId', 'JobItemId', 'Incomplete', 'AssembledandShipped')]
newjobs$MonthStarted = lubridate::month(newjobs$Incomplete, T, F)
newjobs$YearStarted = lubridate::year(newjobs$Incomplete)
newjobs = newjobs[newjobs$YearStarted %in% c(this_yr, last_yr), ]
newjobs = aggregate(JobId ~ MonthStarted + YearStarted, data=newjobs, FUN=len_unique)

newjobs_out = tidyr::spread(newjobs, 'YearStarted', 'JobId')
rownames(newjobs_out) = newjobs_out$MonthStarted; newjobs_out$MonthStarted = NULL
newjobs_out
```

## Jobs In vs. Jobs Out

[[EXPERIMENTAL & DERIVED FROM THROUGHPUT & NEW JOBS DATA]]

```{r jobsin_jobsout}
PIPE$Month = lubridate::month(PIPE$Date, T, F)
PIPE$Year = lubridate::year(PIPE$Date)
start_pipe = PIPE[!duplicated(PIPE[, c('Month', 'Year')]), ]
start_pipe = start_pipe[start_pipe$Year %in% c(this_yr, last_yr), ]
starting_pipeline <- start_pipe[1, 'Pipeline']

names(throughput) = c('Month', 'Year', 'Throughput')
names(newjobs) = c('Month', 'Year', 'NewJobs')
inout_df = merge(throughput, newjobs, on=c('Year', 'Month'), how='outer')
inout_df$NetNewJobs = inout_df$NewJobs - inout_df$Throughput
inout_df = inout_df[order(inout_df$Year, inout_df$Month), ]
inout_df$StartingPipeline = inout_df$EndingPipeline = NULL
inout_df[1, 'StartingPipeline'] = starting_pipeline
inout_df[1, 'EndingPipeline'] = inout_df[1, 'NetNewJobs'] + starting_pipeline

for (i in 1:nrow(inout_df)) {
  if (i != nrow(inout_df)) {
    inout_df[i+1, 'StartingPipeline'] = inout_df[i, 'EndingPipeline']
    inout_df[i+1, 'EndingPipeline'] = inout_df[i+1, 'StartingPipeline'] + inout_df[i+1, 'NetNewJobs']
  } else {
    inout_df[i+1, 'StartingPipeline'] = inout_df[i, 'EndingPipeline']
    inout_df[i, 'EndingPipeline'] = NA #inout_df[i+1, 'StartingPipeline'] + inout_df[i+1, 'NetNewJobs']
  }
}

rownames(inout_df) = NULL
inout_df = inout_df[!is.na(inout_df$Year), ]
inout_df$AvgPipeline = rowMeans(inout_df[, c('StartingPipeline', 'EndingPipeline')])

#gvisCandlestickChart(inout_df[, c('StartingPipeline','EndingPipeline')])
plt_data <- inout_df[1:nrow(inout_df)-1, ]
plt_data1 <- melt(plt_data[, 1:4], c('Year', 'Month'))

ggplot(plt_data1, aes(x=Month, y=value, group=variable)) + 
  geom_line(aes(colour=variable), size=1, alpha=0.8) +
  geom_point(aes(colour=variable)) + 
  facet_wrap(~Year) +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  labs(x='', y='Number of Jobs', title='Throughput vs. New Jobs')

plt_data2 <- melt(plt_data[, c('Month', 'Year', 'StartingPipeline', 'EndingPipeline')], c('Year', 'Month'))
#plt_data2$grp = ifelse(plt_data2$variable=='NetNewJobs', 'Net New Jobs', 'Pipeline')

ggplot(plt_data2, aes(x=Month, y=value, group=Month)) + 
  geom_line(alpha=0.5, size=3) +
  #geom_line(aes(x=Month, y=value, group=variable, colour=variable), 
  #          alpha=0.8, size=1.5) +
  #scale_colour_gradient(low='red', high='green') +
  geom_point(aes(colour=variable), size=3.5) + 
  facet_grid(~ Year) +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  labs(x='', y='Number of Jobs', title='Starting Pipeline vs. Ending Pipeline\nBy Month')

rownames(inout_df) = paste0(as.character(inout_df$Month), ' ', as.character(inout_df$Year))
inout_df[, c('Month', 'Year')] = NULL

annualized_turnover = round(mean(inout_df$Throughput, na.rm=T) / mean(inout_df$AvgPipeline, na.rm=T) * 12, 2)
print(paste0('Turnover Rate per year = ', annualized_turnover, '\n'))

inout_df
```



## Types of Graphics Jobs

### Accessories vs. Prints

To highlight the heterogeneity in the types of jobs Graphics produces, this section considers the following items as "accessories;" all else is considered "print." 

  - Menu Book
  - Table Top Wrap
  - TT A-Frame Holder
  - TT Accrylic Stand
  - TT Flip Stand
  - Vivid Board
  
The data & figures below considers *projects that have been finished this year* only. Price and turnaround are shown as averages, while Jobs and Job Items are generated using a "count unique" function.

```{r heterogeneity_jobs}
jobtypes = df_thisyr[ , c('ItemCategory','PosterPrice',
                          'JobId','JobItemId','JobTurnaround')]

## define accessories for later
accessories = c('Menu Books','Table Top Wrap','TT A-Frame Holder','TT A-Frame Holder (Holder Only)', 
                'TT Acrylic Stand','TT Acrylic Stand (Stand Only)','TT Flip Stand','TT Flip Stand (Stand Only)',
                'Vivid Board - Dry Erase','Vivid Board - Dry Erase','Light Box')
jobtypes$AccessoryOrPrint = ifelse(jobtypes$ItemCategory %in% accessories, 'Accessory', 
                                   'Print')
jobtypes = jobtypes[is.na(jobtypes$JobTurnaround)==F, ]

## Custom categories from Rachel
jt3 = aggregate(cbind(JobTurnaround, PosterPrice) ~ AccessoryOrPrint, 
                data=jobtypes, FUN=function(x) round(mean(x,na.rm=T), 1))
jt4 = aggregate(cbind(JobId, JobItemId) ~ AccessoryOrPrint, 
                data=jobtypes, FUN=len_unique)

acc_or_pri = merge(jt3, jt4, on='AccessoryOrPrint', how='all')
rownames(acc_or_pri) = acc_or_pri$AccessoryOrPrint
acc_or_pri$AccessoryOrPrint = NULL
names(acc_or_pri) = c('Turnaround','Price','Jobs','Items')
acc_or_pri = acc_or_pri[order(acc_or_pri$Turnaround, decreasing=T), ]

acc_or_pri

## Get more granular
jt1 = aggregate(cbind(JobTurnaround, PosterPrice) ~ ItemCategory, 
                data=jobtypes, FUN=function(x) round(mean(x,na.rm=T), 1))
jt2 = aggregate(cbind(JobId, JobItemId) ~ ItemCategory, 
                data=jobtypes, FUN=len_unique)

job_typ = merge(jt1, jt2, on='ItemCategory', how='all')
rownames(job_typ) = job_typ$ItemCategory
job_typ$ItemCategory = NULL
names(job_typ) = c('Turnaround','Price','Jobs','Items')
job_typ = job_typ[order(job_typ$Turnaround, decreasing=T), ]

job_typ
```

### Menus vs. Non-Menus

Menus are assumed to have more work associated with them. A job is considered a Menu if it is a member of the following list:

  - Menu Books
  - Drink List
  - Folded Drink List
  - Tri-Fold Drink List
  - Folded Menu Cards
  - Menu Card - Small Format (QTY = Total Pages)

Prices & Turnaround are shown as averages.

```{r menus_v_nonmenus}
menutypes = df_thisyr[ , c('ItemCategory','PosterPrice',
                          'JobId','JobItemId','JobTurnaround','Menu')]

menutypes = menutypes[is.na(menutypes$JobTurnaround)==F, ]

## Custom categories from Rachel
jt5 = aggregate(cbind(JobTurnaround, PosterPrice) ~ Menu, 
                data=menutypes, FUN=function(x) round(mean(x,na.rm=T), 1))
jt6 = aggregate(cbind(JobId, JobItemId) ~ Menu, 
                data=menutypes, FUN=len_unique)

menuz_df = merge(jt5, jt6, on='Menu', how='all')
menuz_df$Menu = ifelse(menuz_df$Menu==TRUE, 'Menu Jobs', 'Non-Menu Jobs')
rownames(menuz_df) = menuz_df$Menu
menuz_df$Menu = NULL
names(menuz_df) = c('Turnaround','Price','Jobs','Items')
menuz_df = menuz_df[order(menuz_df$Turnaround, decreasing=T), ]

menuz_df
```


<!-- ```{r menus_v_nonmenus_bymo}  -->
<!-- menutypes = df_thisyr[ , c('ItemCategory','PosterPrice','KickoffMonth', -->
<!--                           'JobId','JobItemId','JobTurnaround','Menu')] -->

<!-- menutypes = menutypes[is.na(menutypes$JobTurnaround)==F, ] -->

<!-- ## Custom categories from Rachel -->
<!-- jt5 = aggregate(cbind(JobTurnaround, PosterPrice) ~ Menu + KickoffMonth, -->
<!--                 data=menutypes, FUN=function(x) round(mean(x,na.rm=T), 1)) -->
<!-- jt6 = aggregate(cbind(JobId, JobItemId) ~ Menu, -->
<!--                 data=menutypes, FUN=len_unique) -->

<!-- menuz_df = merge(jt5, jt6, on='Menu', how='all') -->
<!-- menuz_df$Menu = ifelse(menuz_df$Menu==TRUE, 'Menu Jobs', 'Non-Menu Jobs') -->
<!-- rownames(menuz_df) = menuz_df$Menu -->
<!-- menuz_df$Menu = NULL -->
<!-- names(menuz_df) = c('Turnaround','Price','Jobs','Items') -->
<!-- menuz_df = menuz_df[order(menuz_df$Turnaround, decreasing=T), ] -->

<!-- menuz_df -->
<!-- ``` -->







## Active Development for Graphics Metrics
Currently two metrics that were requested are not available. 

  - On-Time completion of job: The field for Requested Finish Date in POSTer is unreliable as of now for various reasons. It defaults to 2 weeks, and is not always updated. If some sort of guidelines are issued to this regard then the field will need to be added to the main Dive from which this data is acquired (which is really just a massive dump).
  - Number of "rush" jobs: The "rush" field is not passed from POSTer to Diver in the raw model. When this field is passed to Diver the metric will be added.
  - Derive the carrying cost at all points in the past to establish what the departmental carrying capacity is; helps planning for the future. Show in a time series plot.
  - Quantify demand; forecast it using time-series methodology (e.g. exponential smoothing).
  - Add in yearly comparison by designer per Rachel's request.



<br><br><br><br><br>





# Measures of Success for Major Brands

This section was designed to provide Leadership succinct insights on Graphics impact on the wider organization. The goal is for this section to contain everything that has to do with Graphics, yet is not immediately relevant to managing the graphics team, workflow or personnel. 



## By Warehouse

### YTD Number of Jobs by Warehouse

Month below is defined as the Incomplete month, or the month in which the Job started.

```{r bylocation_bymo, fig.height=5, fig.width=9}
kickedoff_byhouse = aggregate(JobId ~ KickoffYear + Warehouse, data=df_ytd_thislast, FUN=len_unique)
kickedoff_byhouse = kickedoff_byhouse[kickedoff_byhouse$KickoffYear != two_yrs_ago, ]
kickedoff_byhouse = spread(kickedoff_byhouse, 'KickoffYear', 'JobId')
rownames(kickedoff_byhouse) = kickedoff_byhouse$Warehouse
kickedoff_byhouse$Warehouse = NULL

kickedoff_byhouse$`Percent Change (%)` = pct_chg(kickedoff_byhouse[, as.character(this_yr)], 
                                                 kickedoff_byhouse[, as.character(last_yr)])
kickedoff_byhouse

kickedoff_byhouse$Loc = rownames(kickedoff_byhouse)
kickedoff_byhouse = melt(kickedoff_byhouse, 'Loc', c('2016','2017'))

## Plot for quick view
ggplot(kickedoff_byhouse, aes(x=Loc, y=value, group=variable)) +
  geom_bar(stat='identity', position='dodge', aes(fill=variable), colour='black') +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90, hjust=1)) +
  labs(x='Warehouse', y='Projects Kicked Off, Year-over-Year',title='Projects Kicked Off by House')
```

### Number of Jobs & Job Items, Year-over-Year by Month

The data shown below includes records for this year and last year *through today*. For example, if today is June 20th, then the dataset will contain January through the 171st day of both this year and last year. Both Jobs and Job Items are shown (along with their YOY percent changes). 

It should be noted that jobs that were kicked off yet abandoned are no longer included in the figures below.

<!-- ```{r bylocation_ytd_kickedoff} -->
<!-- kickedoff_byhouse_bymo = aggregate(cbind(JobId,JobItemId) ~ KickoffYear + KickoffMonth + Warehouse,  -->
<!--                               data=df_ytd_thislast, FUN=len_unique) -->
<!-- kickedoff_byhouse_bymo = kickedoff_byhouse_bymo[kickedoff_byhouse_bymo$KickoffYear != two_yrs_ago &  -->
<!--                                         kickedoff_byhouse_bymo$KickoffMonth %in% ytd_months, ] -->

<!-- kickedoff_byhouse_bymo = reshape2::melt(kickedoff_byhouse_bymo, names(kickedoff_byhouse_bymo)[1:3]) -->
<!-- kickedoff_byhouse_bymo = spread(kickedoff_byhouse_bymo, 'variable', 'value') -->

<!-- kickedoff_byhouse_bymo = reshape(kickedoff_byhouse_bymo, timevar='KickoffYear', idvar=c('Warehouse','KickoffMonth'), direction='wide') -->
<!-- kickedoff_byhouse_bymo$KickoffMonth = factor(kickedoff_byhouse_bymo$KickoffMonth,  -->
<!--                                              levels=c('January','February','March','April','May','June', -->
<!--                                                       'July','August','September','October','November','December')) -->
<!-- kickedoff_byhouse_bymo$Warehouse = factor(kickedoff_byhouse_bymo$Warehouse, levels=c('ST LOUIS','KANSAS CITY','MID MISSOURI')) -->
<!-- kickedoff_byhouse_bymo = kickedoff_byhouse_bymo %>% arrange(Warehouse, KickoffMonth) -->
<!-- kickedoff_byhouse_bymo$WarehouseMonth = paste0(kickedoff_byhouse_bymo$Warehouse, ' - ', substr(kickedoff_byhouse_bymo$KickoffMonth,1,3)) -->
<!-- rownames(kickedoff_byhouse_bymo) = kickedoff_byhouse_bymo$WarehouseMonth -->
<!-- kickedoff_byhouse_bymo$KickoffMonth = kickedoff_byhouse_bymo$Warehouse = kickedoff_byhouse_bymo$WarehouseMonth = NULL -->

<!-- ## Set names -->
<!-- names(kickedoff_byhouse_bymo) = c(paste0('Jobs ',last_yr), -->
<!--                                   paste0('Items ', last_yr),  -->
<!--                                   paste0('Jobs ',this_yr), -->
<!--                                   paste0('Items ', this_yr)) -->
<!-- kickedoff_byhouse_bymo$`Jobs Chg. (%)` = pct_chg(kickedoff_byhouse_bymo[,paste0('Jobs ',this_yr)],  -->
<!--                                                       kickedoff_byhouse_bymo[,paste0('Jobs ',last_yr)]) -->
<!-- kickedoff_byhouse_bymo$`Items Chg. (%)` = pct_chg(kickedoff_byhouse_bymo[,paste0('Items ',this_yr)],  -->
<!--                                                       kickedoff_byhouse_bymo[,paste0('Items ',last_yr)]) -->

<!-- ## Rearrange for readability -->
<!-- kickedoff_byhouse_bymo = kickedoff_byhouse_bymo[, c(paste0('Jobs ',last_yr), paste0('Jobs ',this_yr), 'Jobs Chg. (%)', -->
<!--                                                    paste0('Items ', last_yr),paste0('Items ', this_yr), 'Items Chg. (%)')] -->
<!-- kickedoff_byhouse_bymo -->
<!-- ``` -->



### YTD Graphics Profit by Warehouse

Profit in the months so far this year (i.e. YTD months), year-over-year. Graphics Profit is defined as YTD Poster Price minus YTD Charge Back Price.

```{r ytd_pctprofit}
profit_byhouse = aggregate(Profit ~ KickoffYear + Warehouse, data=df_ytd_thislast, FUN=function(x) round(sum(x, na.rm=T), 2))
profit_byhouse = profit_byhouse[profit_byhouse$KickoffYear != two_yrs_ago, ]
profit_byhouse = spread(profit_byhouse, 'KickoffYear', 'Profit')
rownames(profit_byhouse) = profit_byhouse$Warehouse
profit_byhouse$Warehouse = NULL

profit_byhouse$`Percent Change (%)` = pct_chg(profit_byhouse[, as.character(this_yr)], profit_byhouse[, as.character(last_yr)])
profit_byhouse
```





## By Customer Account

Top customer accounts *(by number of Graphics Jobs)* YTD, compared to the same period last year.

```{r jobs_byaccount}
NOT_REAL_CUSTOMERS = c('GENERAL MARKET ALL-STL','GENERAL MARKET ALL-MMS',
                       'GENERAL MARKET ALL-KC','GENERAL MARKET ALL-MMN','',
                       'MAJOR BRANDS INTERNAL-STL','GENERAL MARKET ON-PREMISE STL',
                       'MAJOR BRANDS INTERNAL-KC')

jobs_byaccount = aggregate(JobId ~ KickoffYear + Customer, data=df_ytd_thislast, FUN=len_unique)
jobs_byaccount = jobs_byaccount[jobs_byaccount$KickoffYear != two_yrs_ago, ]
jobs_byaccount = spread(jobs_byaccount, 'KickoffYear', 'JobId')
jobs_byaccount = jobs_byaccount[jobs_byaccount$Customer %!in% NOT_REAL_CUSTOMERS, ]
rownames(jobs_byaccount) = jobs_byaccount$Customer
jobs_byaccount$Customer = NULL

jobs_byaccount$`Percent Change (%)` = pct_chg(jobs_byaccount[, as.character(this_yr)], 
                                                 jobs_byaccount[, as.character(last_yr)])
jobs_byaccount = jobs_byaccount[order(jobs_byaccount[, as.character(this_yr)], decreasing=T), ]
head(jobs_byaccount, 50)
```

Top customer accounts *(by Graphics Profit)* YTD, compared to the same period last year.

```{r profit_byaccount}
profit_byaccount = aggregate(Profit ~ KickoffYear + Customer, data=df_ytd_thislast, FUN=function(x) round(sum(x, na.rm=T), 2))
profit_byaccount = profit_byaccount[profit_byaccount$KickoffYear != two_yrs_ago, ]
profit_byaccount = spread(profit_byaccount, 'KickoffYear', 'Profit')
profit_byaccount = profit_byaccount[profit_byaccount$Customer %!in% NOT_REAL_CUSTOMERS, ]
rownames(profit_byaccount) = profit_byaccount$Customer
profit_byaccount$Customer = NULL

profit_byaccount$`Percent Change (%)` = pct_chg(profit_byaccount[, as.character(this_yr)], 
                                                 profit_byaccount[, as.character(last_yr)])
profit_byaccount = profit_byaccount[order(profit_byaccount[, as.character(this_yr)], decreasing=T), ]
head(profit_byaccount, 50)
```





## By Supplier

Top suppliers *(by number of Graphics Jobs)* YTD, compared to the same period last year.

```{r jobs_bysupplier}
jobs_bysupplier = aggregate(JobId ~ KickoffYear + Supplier, data=df_ytd_thislast, FUN=len_unique)
jobs_bysupplier = jobs_bysupplier[jobs_bysupplier$KickoffYear != two_yrs_ago, ]
jobs_bysupplier = spread(jobs_bysupplier, 'KickoffYear', 'JobId')
jobs_bysupplier = jobs_bysupplier[jobs_bysupplier$Supplier != '', ]
rownames(jobs_bysupplier) = jobs_bysupplier$Supplier
jobs_bysupplier$Supplier = NULL

jobs_bysupplier$`Percent Change (%)` = pct_chg(jobs_bysupplier[, as.character(this_yr)], 
                                                 jobs_bysupplier[, as.character(last_yr)])
# jobs_bysupplier = jobs_bysupplier[jobs_bysupplier$`2017` != 0]
jobs_bysupplier = jobs_bysupplier[order(jobs_bysupplier[, as.character(this_yr)], decreasing=T), ]
head(jobs_bysupplier, 35)
```

Top suppliers *(by Graphics Profit)* YTD, compared to the same period last year.

```{r profit_bysupplier}
profit_bysupplier = aggregate(Profit ~ KickoffYear + Supplier, data=df_ytd_thislast, FUN=function(x) round(sum(x, na.rm=T), 2))
profit_bysupplier = profit_bysupplier[profit_bysupplier$KickoffYear != two_yrs_ago, ]
profit_bysupplier = spread(profit_bysupplier, 'KickoffYear', 'Profit')
profit_bysupplier = profit_bysupplier[profit_bysupplier$Supplier != '', ]
rownames(profit_bysupplier) = profit_bysupplier$Supplier
profit_bysupplier$Supplier = NULL

profit_bysupplier$`Percent Change (%)` = pct_chg(profit_bysupplier[, as.character(this_yr)], 
                                                 profit_bysupplier[, as.character(last_yr)])
# profit_bysupplier = profit_bysupplier[profit_bysupplier$`2017` != 0]
profit_bysupplier = profit_bysupplier[order(profit_bysupplier[, as.character(this_yr)], decreasing=T), ]
head(profit_bysupplier, 35)
```








## By Brand

Below displays the top Brands *(sorted in descending order by Number of Jobs)* for this year only. 

```{r brands_customers}
brands = df_thisyr[,c('Product','Supplier','ChargebackTotal','PosterPrice',
                            'ItemCategory','JobId','JobItemId')]
brands = brands[brands$Product != '', ]
b1 = aggregate(cbind(ChargebackTotal, PosterPrice) ~ Supplier + Product, data=brands, FUN=function(x) round(sum(x, na.rm=T), 0))
b1$Profit = round(b1$PosterPrice - b1$ChargebackTotal, 0)
b2 = aggregate(cbind(JobId, JobItemId) ~ Supplier + Product, data=brands, FUN=len_unique)

brands = merge(b1, b2, on=c('Supplier','Product'), how='all')
rownames(brands) = paste0(brands$Product, '-', brands$Supplier)
brands$Product = NULL
names(brands) = c('Supplier','Chargeback','Price','Profit','Jobs','Job Items')
brands = brands[order(brands$Jobs, decreasing=T), ]
brands$Supplier = NULL

head(brands, 50)
```







<!-- ```{r network_x} -->
<!-- library(ggnet) -->
<!-- library(GGally) -->
<!-- library(network) -->
<!-- library(sna) -->
<!-- net = data.frame(Brand=df_ytd_thislast$Brand,  -->
<!--                  Customer=df_ytd_thislast$Customer, -->
<!--                  weight=df_ytd_thislast$PosterPrice) -->
<!-- net = net[(net$Brand != '') & (net$Customer != '') &(is.na(net$weight)==F), ] -->
<!-- net = aggregate(weight ~ Brand + Customer, data=net, FUN=function(x) round(sum(x, na.rm=T), 2)) -->
<!-- net = network(net) -->

<!-- ggnet(net, node.size=3, label=T, edge.size='weight') -->
<!-- ``` -->







<!-- ## By Requester -->

<!-- Top Salesperson requesters who input jobs for this year only, sorted by number of jobs. Note that the Graphics department inputs many jobs as proxies for the true requester; these are shown separately. Requests that were entered by the Graphics department on behalf of someone else will show up in the second table below. -->

<!-- # ```{r byrequester} -->
<!-- # head(byrequester, 35) -->
<!-- # bygraphics -->
<!-- # ``` -->






# What's Working? What's Not?

Please provide feedback to paul.washburn@majorbrands.com.















































## Logical Future Improvements
  - Instead of placing all brand mentions for other distributors on one line in POSTer, store each mention as a separate line. This will create marginally more work for Graphics, yet will immensely improve the insights we will be able to gain into individual brands, our place in the market, and provide a more detailed view of our market share We can then use formal tests to see which Graphics products are working and which are not. 



















































<!-- ## Python to process -->
<!-- ```{python} -->
<!-- import pandas as pd -->

<!-- path = 'C:/Users/pmwash/Desktop/Re-Engineered Reports/Graphics/intermediate_graphics_data_dump_diver.csv' -->
<!-- df = pd.read_csv(path, header=0) -->
<!-- ## Use Python to process strings -->
<!-- df.head() -->
<!-- ``` -->






































